---
title: 面经
date: 2022-01-03
---


1. 使用redux的好处，以及和mobx的区别？

redux的三大优势：
* 单一数据源
* 状态是只读的
* 状态的改变只能通过纯函数改变

redux和mobx区别:
redux: 函数式编程思想、单一store，plan object保存数据，手动处理变化后的操作、使用不可变状态，意味着状态只读，使用纯函数修改，返回的是一个新的状态、提供时间回溯的开发工具。
mobx:面向对象思维、多个store、observable自动响应变化操作、mobx状态可变，直接修改、更多的抽象和封装，调试复杂，结果难以预测。


2. class组件和函数组件的区别？

3. useState为什么不能放到条件语句里面？
React通过单链表来管理Hooks。update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState 写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。

4. 实现一个Promise.all
```js
function promiseAll(promises){
    return new Promise((resolved, rejected) => {
        let resultCount = 0;
        let results = new Array(promises.length);

        for(let i = 0; i < promises.length; i++){
            promises[i].then(value => {
                resultCount++
                results[i] = value
                if(resultCount === promises.length){
                    return resolved(results)
                }
            }, error => {
                rejected(error)
            })
        }
    })
}
```

5. React SSR是怎么实现的？


6. 有用过代码规范相关的吗？Eslint 和 Prettier 冲突怎么解决？
https://www.jianshu.com/p/b3a693cdcee9


7. 实现一个数组转树形结构的函数
```js
const data = [
  { id: 1, text: 't1', parentId: 0 },
  { id: 11, text: 't11', parentId: 1 },
  { id: 12, text: 't12', parentId: 1 },
  { id: 2, text: 't2', parentId: 0 },
  { id: 21, text: 't21', parentId: 2 },
  { id: 3, text: 't3', parentId: 0 }
]

function arrToTree(data, id, parentId, children){
  let cloneData = JSON.parse(JSON.stringify(data))
  return cloneData.filter(father => {
    let newArr = cloneData.filter(child => {
      return father[id] === child[parentId]
    })
    father[children] = newArr
    return father[parentId] === 0
  })
}

const treeData = arrToTree(data, 'id', 'parentId', 'children')

console.log(JSON.stringify(treeData))

[
  {
      "id": 1,
      "text": "t1",
      "parentId": 0,
      "children": [
          {
              "id": 11,
              "text": "t11",
              "parentId": 1,
              "children": []
          },
          {
              "id": 12,
              "text": "t12",
              "parentId": 1,
              "children": []
          }
      ]
  },
  {
      "id": 2,
      "text": "t2",
      "parentId": 0,
      "children": [
          {
              "id": 21,
              "text": "t21",
              "parentId": 2,
              "children": []
          }
      ]
  },
  {
      "id": 3,
      "text": "t3",
      "parentId": 0,
      "children": []
  }
]
```


8. 有没有做过性能优化相关的？



9. 实现一个深拷贝
```js
function deepClone(obj){
    function isObject(o){
        return (typeof o === 'object' || typeof o === 'function') && o !== null
    }

    if(!isObject(obj)){
        throw new Error('非对象')
    }

    let isArray = Array.isArray(obj)
    let newObj = isArray ? [...obj] : {...obj}
    Reflect.ownKeys(newObj).forEach(key => {
        newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
    })

    return newObj
}
```

10. 讲一讲微前端是怎么实现的？怎么独立部署？子应用通信怎么做？


11. webpack构建流程是怎样的？
Webpack在启动后，会从Entry开始，递归解析Entry依赖的所有Module，每找到一个Module，就会根据Module.rules里配置的Loader规则进行相应的转换处理，对Module进行转换后，再解析出当前Module依赖的Module，这些Module会以Entry为单位进行分组，即为一个Chunk。因此一个Chunk，就是一个Entry及其所有依赖的Module合并的结果。最后Webpack会将所有的Chunk转换成文件输出Output。在整个构建流程中，Webpack会在恰当的时机执行Plugin里定义的逻辑，从而完成Plugin插件的优化任务。

12. webpack loader和plugin的原理和区别？

* Loader用于对模块文件进行编译转换和加载处理，在module.rules数组中进行配置，它用于告诉Webpack在遇到哪些文件时使用哪些Loader去加载和转换
* Plugin用于扩展Webpack功能，实现原理是在构建流程里注入钩子函数。在plugins数组中进行配置。

13. webpack 怎么做分包？
14. webpack 性能优化
15. react diff的复杂度，以及react diff的原理？
16. 谈谈react hooks的优缺点？


17. 从输入url到页面渲染经过了哪些步骤？


18. 知道BFC吗？使用场景有哪些？

BFC 即 Block Formatting Contexts (块级格式化上下文)。
具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。


19. 怎么判断是否时数组？
20. 页面卡顿怎么去定位？
21. 数组有10万个数据，取第一个和取第10万个的耗时多久？
22. 工作中遇到最难的问题？
23. 写个防抖和节流函数？
```js
/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */
function debounce(func,wait,immediate) {
    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(() => {
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
}


/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */
function throttle(func, wait ,type) {
    if(type===1){
        let previous = 0;
    }else if(type===2){
        let timeout;
    }
    return function() {
        let context = this;
        let args = arguments;
        if(type===1){
            let now = Date.now();

            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        }else if(type===2){
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }
    }
}
```


24. http2的相关特性？

* 二进制分帧（HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码）
* 多路复用
* 服务器推送
* 头部压缩

25. viewport和移动端布局方案？
26. 实现一个compose函数
```js
function compose(...fns) { // fns是传入的函数
  const fn = fns.pop();
  return (...args) => {
    fn(...args);
    if (fns.length > 0) {
      compose(...fns);
    }
  };
}
```

27. 讲一下react fiber?
28. 怎么优化h5加载速度？怎么实现h5页面秒开？
29. js bridge通信原理？
30. useReducer比redux好在哪里？
31. react setState 怎么获取到更新后的值？异步函数中为什么setState会立即更新？